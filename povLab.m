classdef povlab < handle
% This is the core class of PovLab, all toolbox functions implemented here
%
% <a href="https://wiki.povray.org/content/Documentation:Contents">POV Documentation</a> - Please check complete POV-Ray reference for datails
%
% EXAMPLES
%
% <a href="matlab:if exist('./examples', 'dir') cd 'examples'; end;edit ex_surface">Surface</a> - 3D surface based on data returned by Matlab's 'surf' function
% <a href="matlab:if exist('./examples', 'dir') cd 'examples'; end;edit ex_csg">CSG</a> - Constructive solid geometry primitives and methods
% <a href="matlab:if exist('./examples', 'dir') cd 'examples'; end;edit ex_lathe">Lathe</a> - Lathe objects creation
% <a href="matlab:if exist('./examples', 'dir') cd 'examples'; end;edit ex_plot">Plot</a> - Plots 2D graph of function
% <a href="matlab:if exist('./examples', 'dir') cd 'examples'; end;edit ex_coneplot">Coneplot</a> - 3D Coneplot graph based on Matlab's 'wind' dataset
% <a href="matlab:if exist('./examples', 'dir') cd 'examples'; end;edit ex_streamline">Streamline</a> - 3D Stremline graph based on Matlab's 'wind' dataset
% <a href="matlab:if exist('./examples', 'dir') cd 'examples'; end;edit ex_volume">Volume</a> - Volume visualization of Matlab's 'mri' dataset
%
    properties (Access = private)
        version     {mustBeNonempty} = "0.0620";
        pov_version {mustBeNonempty} = "3.7";
        pov_path    {mustBeNonempty} = "pvengine.exe";
        out_dir     {mustBeNonempty} = ".";
        scene_file  {mustBeNonempty} = "scene.pov";
        image_file  {mustBeNonempty} = "image.png";
        
        fh = 0;

        % Common textures
        tex_default;

        tex_axis_common;
        tex_axis_x;
        tex_axis_y;
        tex_axis_z;
        tex_plane;
    end

    methods (Access = public)
        function o = povlab(pov_version, pov_path, out_dir)
        % Constructor
        %
        % SYNOPSIS
        %
        % pl = povlab(pov_version, pov_path, out_dir)
        %
        % DESCRIPTION
        %
        % RETURN VALUE
        %
        % Returns object of 'povlab' class
        %
        % EXAMPLES
        %
        % <a href="matlab:edit ex_surface">Surface</a> - 3D surface based on data returned by Matlab's 'surf' function
        % <a href="matlab:edit ex_csg">CSG</a> - Constructive solid geometry primitives and methods
        % <a href="matlab:edit ex_lathe">Lathe</a> - Lathe objects creation
        % <a href="matlab:edit ex_plot">Plot</a> - Plots 2D graph of function

            if nargin == 3
                o.pov_version = pov_version;
                o.pov_path    = pov_path;
                o.out_dir     = out_dir;

                fclose('all');
                if exist(o.out_dir, 'dir')
                    rmdir(o.out_dir, 's')
                end
                mkdir(o.out_dir);

                povlab_include_file = get_root_dir() + "/include/povlab.inc";
                copyfile(povlab_include_file, o.out_dir);
            end
        end

        function include_begin(o, name)
            % include_begin method help
            o.fh = fopen(o.out_dir + "/" + name + ".inc",'w');
        end

        function include_end(o)
            % include_end method help
            fclose(o.fh);
        end
        
        % Scene begin
        function scene_begin(o, varargin)
            % Opens new scene, corresponding scene_end() should be included after all scene content
            %
            % Please find scene_begin() usage in following examples <a href="matlab:doc ex_csg">ex_csg</a>, <a href="matlab:doc ex_surface">ex_surface</a>, <a href="matlab:doc ex_lathe">ex_lathe</a>
            
            p = inputParser;
            addParameter(p,'scene_file', 'out.pov', @o.check_string);
            addParameter(p,'image_file', 'out.png', @o.check_string);
            parse(p,varargin{:});

            % Store
            o.scene_file = p.Results.scene_file;
            o.image_file = o.out_dir + "/" + p.Results.image_file;
            
            sf = o.out_dir + "/" + o.scene_file;
            if exist(sf, 'file')==2
                delete(sf);
            end
            if exist(o.image_file, 'file')==2
                delete(o.image_file);
            end

            o.fh = fopen(o.out_dir + "/" + o.scene_file,'w');
            % Write header
            fprintf(o.fh, ['//\n// Generated by POV-Lab (ver. %s)\n' ...
                           '// Source: https://www.mathworks.com/matlabcentral/fileexchange/123520-pov-lab-matlab-interface-to-pov-ray\n//\n' ...
                           '// Matlab version:  %s\n' ...
                           '// POV-Ray version: %s\n//\n' ...
                           '// Date: %s\n//\n'......                           
                           '#version %s;\n\n'], ...
                           o.version, version(), o.pov_version, datetime(), o.pov_version);

            o.include("povlab");
        end
        
        % Scene end
        function scene_end(o)
        % Closes scene, opened by scene_begin(), should be included after all scene content
        %
        % Please find scene_end() usage in following examples <a href="matlab:doc ex_csg">ex_csg</a>, <a href="matlab:doc ex_surface">ex_surface</a>, <a href="matlab:doc ex_lathe">ex_lathe</a>
            
            fclose(o.fh);
        end

        % Lights begin
        function lights_begin(o)
            % lights_begin method help
            o.fh = fopen(o.out_dir + "/lights.inc",'w');
        end
        
        % Lights end
        function lights_end(o)
            % lights_end method help
            fclose(o.fh);
        end

        % Helpers begin
        function helpers_begin(o)
            % helpers_begin method help
            o.fh = fopen(o.out_dir + "/helpers.inc",'w');
        end
        
        % Helpers end
        function helpers_end(o)
            % helpers_end method help
            fclose(o.fh);
        end
        
        % Global settings
        function global_settings(o, settings)
            % global_settings method help
            fprintf(o.fh, 'global_settings { %s }\n\n', settings);
        end
        
        % Include
        function include(o, text)
            % include method help
            fprintf(o.fh, '#include "%s.inc"\n', text);
        end
        
        % Declare
        function s = declare(o, symbol, text)
            % declare method help
            fprintf(o.fh, '#declare %s = %s\n', symbol, text);
            s = symbol;
        end

        % Macro
        function macro(o, text)
            % macro method help
            fprintf(o.fh, '#macro %s#end\n\n', text);
        end

        % Raw
        function raw(o, text)
            % raw method help
            fprintf(o.fh, '%s\n\n', text);
        end

        % Camera
        function camera(o, varargin)
            % Creates camera object with desired parameters
            %
            % -- Syntax
            % camera('angle', 25, 'location', [35 20 19], 'look_at', [0 1 3], 'type', 'perspective');
            % type: perspective | orthographic | mesh_camera{MESHCAM_MODIFIERS} | fisheye | ultra_wide_angle |
            %       omnimax | panoramic | cylinder CylinderType | spherical
            %
            % Please find camera() usage in following examples <a href="matlab:doc ex_csg">ex_csg</a>, <a href="matlab:doc ex_surface">ex_surface</a>, <a href="matlab:doc ex_lathe">ex_lathe</a>
            % 
            % <a href="https://wiki.povray.org/content/Reference:Camera">POV Reference:Camera</a> - More about camera
            
            p = inputParser;
            addParameter(p,'type',     'orthographic', @o.check_string);
            addParameter(p,'angle',    65,             @o.check_positive_float);
            addParameter(p,'location', [-10 -10 10],   @o.check_vector3);
            addParameter(p,'look_at',  [0 0 0],        @o.check_vector3);
            addParameter(p,'right',    [-1.33 0 0],    @o.check_vector3); % Set right-handed system by default
            parse(p,varargin{:});

            type     = p.Results.type;
            angle    = p.Results.angle;
            location = p.Results.location;
            look_at  = p.Results.look_at;
            right    = p.Results.right;

            % Write
            fprintf(o.fh, ['camera { %s' ...
                           '         angle %d\n' ...
                           '         location <%0.2f, %0.2f, %0.2f>\n' ...
                           '         right x * image_width / image_height\n' ...
                           '         look_at <%0.2f, %0.2f, %0.2f>\n' ...
                           '         right  <%0.2f, %0.2f, %0.2f0> rotate<90,0,0>}\n\n'], ...
                            type, angle, ...
                            location(1), location(3), -location(2), ... % According to right-handed system
                            look_at(1),  look_at(3),  -look_at(2), ...
                            right(1), right(2), right(3));
        end

        % Light
        function light(o, varargin)
            % <a href="https://wiki.povray.org/content/Reference:Light_Source">POV Reference:Light Source</a> - More about light sources
            p = inputParser;
            addParameter(p,'location',   [0 0 0],          @o.check_vector3);
            addParameter(p,'color',      [1 1 1],          @o.check_vector3);
            addParameter(p,'type',       '',               @o.check_string);
            addParameter(p,'point_at',   [0 0 0],          @o.check_vector3);
            addParameter(p,'radius',     30,               @o.check_positive_float);
            addParameter(p,'falloff',    45,               @o.check_positive_float);
            addParameter(p,'tightness',  0,                @o.check_positive_float);
            addParameter(p,'shadowless', false,            @(x) islogical(x));
            addParameter(p,'visible',    false,            @(x) islogical(x));
            addParameter(p,'fade_power',        10,        @o.check_positive_float);
            addParameter(p,'fade_distance',     10,        @o.check_positive_float);
            addParameter(p,'media_interaction', true,      @(x) islogical(x));
            addParameter(p,'media_attenuation', false,     @(x) islogical(x));
            addParameter(p,'shape_scale',       1,         @o.check_positive_float);
            addParameter(p,'shape_color',       [1 1 1 0], @o.check_vector4);
            parse(p,varargin{:});

            location   = p.Results.location;
            color      = p.Results.color;
            type       = p.Results.type;
            point_at   = p.Results.point_at;
            radius     = p.Results.radius;
            falloff    = p.Results.falloff;
            tightness  = p.Results.tightness;
            shadowless = p.Results.shadowless;
            visible    = p.Results.visible;
            fade_power    = p.Results.fade_power;
            fade_distance = p.Results.fade_distance;
            media_interaction = p.Results.media_interaction;
            media_attenuation = p.Results.media_attenuation;
            shape_scale = p.Results.shape_scale;
            shape_color = p.Results.shape_color;

            if(visible)
                fprintf(o.fh,['#declare Lightsource_Shape_Tex = texture { pigment{ rgbt <%0.2f, %0.2f, %0.2f, %0.2f>}\n'...
                              '                                           finish { phong 1 reflection {0.1 metallic 0.2}}}\n'], ...
                              shape_color(1), shape_color(2), shape_color(3), shape_color(4));

                if(type == "spotlight")
                    target = point_at - location;
                    fprintf(o.fh,'#declare Spotlight_Shape = union { sphere { <0, 0, 0>, 0.25 } cone { <0,0,0>,0,<%0.2f, %0.2f, %0.2f>,0.3 } texture {Lightsource_Shape_Tex}}\n', ...
                                  target(1), ...
                                  target(2), ...
                                  target(3));
                    looks_like = " looks_like {Spotlight_Shape}";
                elseif(type == "cylinder")
                    target = point_at - location;
                    fprintf(o.fh,'#declare Cylinder_Shape = union { sphere { <0, 0, 0>, 0.25 } cylinder { <0,0,0>,<%0.2f, %0.2f, %0.2f>,0.15 } texture {Lightsource_Shape_Tex}}\n', ...
                                  target(1), ...
                                  target(2), ...
                                  target(3));
                    looks_like = " looks_like {Cylinder_Shape}";
                else
                    looks_like = " looks_like {Pointlight_Shape}";
                    fprintf(o.fh,['#declare Pointlight_Shape =\n'...
                                  '         union {sphere { <0, 0, 0>, 0.25 }\n'...
                                  '                cone { <0, 0, 0>, 0.15, <0.6,  0, 0>,0 }\n'...
                                  '                cone { <0, 0, 0>, 0.15, <-0.6, 0, 0>,0 }\n'...
                                  '                cone { <0, 0, 0>, 0.15, <0,  0.6, 0>,0 }\n'...
                                  '                cone { <0, 0 ,0>, 0.15, <0, -0.6, 0>,0 }\n'...
                                  '                cone { <0, 0, 0>, 0.15, <0,  0, 0.6>,0 }\n'...
                                  '                cone { <0, 0, 0>, 0.15, <0,  0,-0.6>,0 }\n'...
                                  '                texture { Lightsource_Shape_Tex }\n'...
                                  '                scale %0.2f}\n'], shape_scale);
                end
            else
                looks_like = "";
            end
            
            if((p.Results.type == ""))
                radius    = "";
                falloff   = "";
                tightness = "";
                point_at  = "";
            elseif (type == "parallel")
                type = sprintf(" %s", type);
                point_at  = sprintf(" point_at <%0.1f, %0.1f, %0.1f>", point_at(1), point_at(2), point_at(3));
                radius    = "";
                falloff   = "";
                tightness = "";
            else
                type = sprintf(" %s", type);
                point_at  = sprintf(" point_at <%0.1f, %0.1f, %0.1f>", point_at(1), point_at(2), point_at(3));
                
                if (ismember('radius', p.UsingDefaults))
                    radius = "";
                else
                    radius = sprintf(" radius %0.2f", radius);
                end

                if (ismember('falloff', p.UsingDefaults))
                    falloff = "";
                else
                    falloff = sprintf(" falloff %0.2f", falloff);
                end

                if (ismember('tightness', p.UsingDefaults))
                    tightness = "";
                else
                    tightness = sprintf(" tightness %0.2f", tightness);
                end
            end

            if(shadowless)
                shadowless = " shadowless";
            else
                shadowless = "";
            end

            if (ismember('fade_power', p.UsingDefaults))
                fade_power = "";
            else
                fade_power = sprintf(" fade_power %0.2f", fade_power);
            end

            if (ismember('fade_distance', p.UsingDefaults))
                fade_distance = "";
            else
                fade_distance = sprintf(" fade_distance %0.2f", fade_distance);
            end
            
            if(media_interaction)
                media_interaction = "";
            else
                media_interaction = " media_interaction off";
            end

            if(media_attenuation)
                media_attenuation = " media_attenuation on";
            else
                media_attenuation = "";
            end

            % Write
            fprintf(o.fh,'light_source{<%0.1f, %0.1f, %0.1f> rgb <%0.2f, %0.2f, %0.2f>%s%s%s%s%s%s%s%s%s%s%s}\n', ...
                          location(1), location(2), location(3), ...
                          color(1), color(2), color(3), ...
                          type, radius, falloff, tightness, point_at, shadowless, fade_power, fade_distance, media_interaction, media_attenuation, looks_like);
        end
       
        % Axis
        function axis(o, varargin)
            % Creates textured axis of desired length and radius
            %
            % SYNOPSIS
            %
            % axis(varargin)
            %
            % DESCRIPTION
            %
            % RETURN VALUE
            %
            % None
            %
            % EXAMPLES
            %
            % <a href="matlab:edit ex_surface">Surface</a> - 3D surface based on data returned by Matlab's 'surf' function
            % <a href="matlab:edit ex_csg">CSG</a> - Constructive solid geometry primitives and methods
            % <a href="matlab:edit ex_lathe">Lathe</a> - Lathe objects creation
            % <a href="matlab:edit ex_plot">Plot</a> - Plots 2D graph of function
            
            p = inputParser;
            addParameter(p,'length', [5 5 5], @o.check_vector3);
            addParameter(p,'tex_common', "tex_axis_common", @o.check_string);
            addParameter(p,'tex_x', "tex_axis_x", @o.check_string);
            addParameter(p,'tex_y', "tex_axis_y", @o.check_string);
            addParameter(p,'tex_z', "tex_axis_z", @o.check_string);
            addParameter(p,'radius', 0.05,        @o.check_positive_float);
            parse(p,varargin{:});
            
            % Write
            length =     p.Results.length;
            tex_common = p.Results.tex_common;
            tex_x =      p.Results.tex_x;
            tex_y =      p.Results.tex_y;
            tex_z =      p.Results.tex_z;
            radius =     p.Results.radius;

            fprintf(o.fh,'object{ axis_xyz( %0.2f, %0.2f, %0.2f, %0.2f,\n        %s, %s, %s, %s) }\n\n', ...
                          length(1), length(2), length(3), radius,...
                          tex_common, tex_x, tex_y, tex_z);
        end

        % Grid
        function grid(o, varargin)
            % grid method help
            p = inputParser;
            addParameter(p,'cell_size',    1,               @o.check_positive_float);
            addParameter(p,'width',        2,               @o.check_positive_int);
            addParameter(p,'height',       2,               @o.check_positive_int);
            addParameter(p,'radius',       0.02,            @o.check_positive_float);
            addParameter(p,'texture',      "tex_grid",      @o.check_string);
            addParameter(p,'texture_odd',  "tex_grid_odd",  @o.check_string);
            addParameter(p,'texture_even', "tex_grid_even", @o.check_string);
            addParameter(p,'scale',        [1 1 1],         @o.check_vector3);
            addParameter(p,'rotate',       [0 0 0],         @o.check_vector3);
            addParameter(p,'translate',    [0 0 0],         @o.check_vector3);
            parse(p,varargin{:});

            cell_size    = p.Results.cell_size;
            width        = p.Results.width;
            height       = p.Results.height;
            radius       = p.Results.radius;
            texture      = p.Results.texture;
            texture_odd  = p.Results.texture_odd;
            texture_even = p.Results.texture_even;
            scale        = p.Results.scale;
            rotate       = p.Results.rotate;
            translate    = p.Results.translate;

            if (~ismember('texture', p.UsingDefaults))
               texture_odd  = texture;
               texture_even = texture;
            end

            % Write
            fprintf(o.fh,['#local gid = "gid"\n' ...
                          'grid(gid, %0.2f, %d, %d, %0.2f, %s, %s);\n'...
                          'object { gid '],...
                          cell_size, width, height, radius, texture_odd, texture_even);
            o.write_transforms(scale, rotate, translate);
        end
        
        function tex = texture(o, varargin)
            % <a href="https://wiki.povray.org/content/Reference:Texture">POV Reference:Texture</a> - More about textures
            p = inputParser;
            addParameter(p,'base', 'Polished_Chrome',  @o.check_string);
            addParameter(p,'pigment',      [0 0 0],    @o.check_vector3);
            addParameter(p,'pigment_odd',  [0 0 0],    @o.check_vector3);
            addParameter(p,'pigment_even', [0 0 0],    @o.check_vector3);
            addParameter(p,'finish', "phong 1 reflection {0.10 metallic 0.4}", @o.check_string);
            % TODO: Fix it
            % addParameter(p,'finish', "finish_default", @o.check_string);
            parse(p,varargin{:});
            base = p.Results.base;
            pigment      = p.Results.pigment;
            pigment_odd  = p.Results.pigment_odd;
            pigment_even = p.Results.pigment_even;
            finish  = p.Results.finish;

            if (~ismember('pigment', p.UsingDefaults))
                tex = sprintf(['texture { %s\n' ...
                               '          pigment{ rgb <%0.2f, %0.2f, %0.2f>}\n'...
                               '          finish { %s }}\n'], ...
                               base, ...
                               pigment(1), pigment(2), pigment(3),...
                               finish);
            else
                tex = sprintf(['texture { %s\n' ...
                               '          pigment{ checker rgb <%0.2f, %0.2f, %0.2f> rgb <%0.2f, %0.2f, %0.2f>  }\n'...
                               '          finish { %s }}\n'], ...
                               base, ...
                               pigment_odd(1), pigment_odd(2), pigment_odd(3), ...
                               pigment_even(1), pigment_even(2), pigment_even(3),...
                               finish);
            end
        end
        
        % Sphere
        function sphere(o, varargin)
            % sphere method help
            p = inputParser;
            addParameter(p,'position',  [0 0 0],       @o.check_vector3);
            addParameter(p,'radius',    1.0,           @o.check_positive_float);
            addParameter(p,'texture',   "tex_default", @o.check_string);
            addParameter(p,'scale',     [1 1 1],       @o.check_vector3);
            addParameter(p,'rotate',    [0 0 0],       @o.check_vector3);
            addParameter(p,'translate', [0 0 0],       @o.check_vector3);
            parse(p,varargin{:});

            position  = p.Results.position;
            radius    = p.Results.radius;
            texture   = p.Results.texture;
            scale     = p.Results.scale;
            rotate    = p.Results.rotate;
            translate = p.Results.translate;

            % Write
            fprintf(o.fh, ['sphere {<%0.2f, %0.2f, %0.2f>, %0.2f\n'...
                           '        texture { %s }\n'],...
                           position(1), position(2), position(3), radius,...
                           texture);
            o.write_transforms(scale, rotate, translate);
        end

        % Box
        function box(o, varargin)
            % Box defined by listing two opposite corners
            %
            % -- Syntax
            % box('llf_corner', [x1 y1 z1], 'urb_corner', [x2 y2 z2]);
            %
            p = inputParser;
            addParameter(p,'llf_corner', [0 0 0],      @o.check_vector3);
            addParameter(p,'urb_corner', [0 0 0],      @o.check_vector3);
            addParameter(p,'texture',   "tex_default", @o.check_string);
            addParameter(p,'scale',     [1 1 1],       @o.check_vector3);
            addParameter(p,'rotate',    [0 0 0],       @o.check_vector3);
            addParameter(p,'translate', [0 0 0],       @o.check_vector3);
            parse(p,varargin{:});

            llf_corner  = p.Results.llf_corner;
            urb_corner  = p.Results.urb_corner;
            texture   = p.Results.texture;
            scale     = p.Results.scale;
            rotate    = p.Results.rotate;
            translate = p.Results.translate;

            % Write
            fprintf(o.fh, ['box {<%0.2f, %0.2f, %0.2f>, <%0.2f, %0.2f, %0.2f>\n'...
                           '        texture { %s }\n'],...
                           llf_corner(1), llf_corner(2), llf_corner(3),...
                           urb_corner(1), urb_corner(2), urb_corner(3),...
                           texture);
            o.write_transforms(scale, rotate, translate);
        end
        
        % Cone
        function cone(o, varargin)
            % Creates a cone by base center location, base radius, cap
            % center location and cap radius
            p = inputParser;
            addParameter(p,'base_point', [0 0 0],      @o.check_vector3);
            addParameter(p,'base_radius',    1.0,      @o.check_positive_float);
            addParameter(p,'cap_point',  [0 0 5],      @o.check_vector3);
            addParameter(p,'cap_radius',       0,      @o.check_positive_float);
            addParameter(p,'texture',   "tex_default", @o.check_string);
            addParameter(p,'scale',      [1 1 1],      @o.check_vector3);
            addParameter(p,'rotate',     [0 0 0],      @o.check_vector3);
            addParameter(p,'translate',  [0 0 0],      @o.check_vector3);
            parse(p,varargin{:});

            base_point  = p.Results.base_point;
            base_radius = p.Results.base_radius;
            cap_point   = p.Results.cap_point;
            cap_radius  = p.Results.cap_radius;
            texture   = p.Results.texture;
            scale     = p.Results.scale;
            rotate    = p.Results.rotate;
            translate = p.Results.translate;

            % Write
            fprintf(o.fh, ['cone {<%0.2f, %0.2f, %0.2f>, %0.2f, <%0.2f, %0.2f, %0.2f>, %0.2f\n'...
                           '        texture { %s }\n'],...
                           base_point(1), base_point(2), base_point(3), base_radius,...
                           cap_point(1),  cap_point(2),  cap_point(3),  cap_radius,...
                           texture);
            o.write_transforms(scale, rotate, translate);
        end

        % Cylinder
        function cylinder(o, varargin)
            % cylinder method help
            p = inputParser;
            addParameter(p,'base_point',[0 0 0],      @o.check_vector3);
            addParameter(p,'cap_point', [0 0 5],      @o.check_vector3);
            addParameter(p,'radius',          0,      @o.check_positive_float);
            addParameter(p,'texture',  "tex_default", @o.check_string);
            addParameter(p,'scale',     [1 1 1],      @o.check_vector3);
            addParameter(p,'rotate',    [0 0 0],      @o.check_vector3);
            addParameter(p,'translate', [0 0 0],      @o.check_vector3);
            parse(p,varargin{:});

            base_point = p.Results.base_point;
            cap_point  = p.Results.cap_point;
            radius     = p.Results.radius;
            texture    = p.Results.texture;
            scale      = p.Results.scale;
            rotate     = p.Results.rotate;
            translate  = p.Results.translate;

            % Write
            fprintf(o.fh, ['cylinder {<%0.2f, %0.2f, %0.2f>, <%0.2f, %0.2f, %0.2f>, %0.2f\n'...
                           '          texture { %s }\n'],...
                           base_point(1), base_point(2), base_point(3),...
                           cap_point(1),  cap_point(2),  cap_point(3), radius,...
                           texture);
            o.write_transforms(scale, rotate, translate);
        end

        % Torus
        function torus(o, varargin)
            % Torus defined by major and minor radiuses
            %
            % -- Syntax
            % torus('radius_maj', r1, 'radius_min' r2);
            %
            p = inputParser;
            addParameter(p,'radius_maj', 1.0,          @o.check_positive_float);
            addParameter(p,'radius_min', 0.5,          @o.check_positive_float);
            addParameter(p,'texture',   "tex_default", @o.check_string);
            addParameter(p,'scale',     [1 1 1],       @o.check_vector3);
            addParameter(p,'rotate',    [0 0 0],       @o.check_vector3);
            addParameter(p,'translate', [0 0 0],       @o.check_vector3);
            parse(p,varargin{:});

            radius_maj   = p.Results.radius_maj;
            radius_min   = p.Results.radius_min;
            texture      = p.Results.texture;
            scale        = p.Results.scale;
            rotate       = p.Results.rotate;
            translate    = p.Results.translate;

            % Write
            fprintf(o.fh, ['torus {%0.2f, %0.2f\n'...
                           '        texture { %s }\n'],...
                           radius_maj, radius_min,...
                           texture);
            o.write_transforms(scale, rotate, translate);
        end
        
        % Lathe
        function lathe(o, varargin)
            % lathe method help
            p = inputParser;
            addParameter(p,'points', [1 0; 1 1],           @o.check_points_list);
            addParameter(p,'spline_type', 'linear_spline', @o.check_string);
            addParameter(p,'sturm',  false,                @islogical);
            addParameter(p,'texture',  "tex_default",      @o.check_string);
            addParameter(p,'scale',     [1 1 1],           @o.check_vector3);
            addParameter(p,'rotate',    [0 0 0],           @o.check_vector3);
            addParameter(p,'translate', [0 0 0],           @o.check_vector3);
            parse(p,varargin{:});

            points      = p.Results.points;
            spline_type = p.Results.spline_type;
            sturm       = p.Results.sturm;
            texture     = p.Results.texture;
            scale       = p.Results.scale;
            rotate      = p.Results.rotate;
            translate   = p.Results.translate;

            if(sturm)
                sturm = "sturm";
            else
                sturm = "";
            end

            % Write
            [npoints, ~] = size(points);
            fprintf(o.fh, 'lathe { %s %d,\n', spline_type, npoints);

            for i=1:npoints
                fprintf(o.fh, '      <%0.2f, %0.2f>\n', points(i,1), points(i,2));
            end

            fprintf(o.fh, ['      %s\n'...
                           '      texture { %s }\n'], sturm, texture);
            o.write_transforms(scale, rotate, translate);
        end

        % Plane
        function plane(o, varargin)
            % Creates a plane by normal and distance from origin
            p = inputParser;
            addParameter(p,'normal',    [0 1 0],     @o.check_vector3);
            addParameter(p,'distance',  0,           @o.check_float);
            addParameter(p,'limits',    [0 0 0 0],   @o.check_vector4);
            addParameter(p,'texture',   "tex_plane", @o.check_string);
            addParameter(p,'scale',     [1 1 1],     @o.check_vector3);
            addParameter(p,'rotate',    [0 0 0],     @o.check_vector3);
            addParameter(p,'translate', [0 0 0],     @o.check_vector3);
            parse(p,varargin{:});

            normal    = p.Results.normal;
            distance  = p.Results.distance;
            limits    = p.Results.limits;
            texture   = p.Results.texture;
            scale     = p.Results.scale;
            rotate    = p.Results.rotate;
            translate = p.Results.translate;
            
            if(ismember('limits', p.UsingDefaults))
                clipped_by = "";
            else
                % TODO: Take distance into account
                clipped_by = sprintf("clipped_by{ box { <%0.2f,%0.2f,%0.2f>, <%0.2f,%0.2f,%0.2f> }}", limits(1), limits(2), limits(2), limits(3), limits(4), limits(4));
            end
            
            % Write
            fprintf(o.fh,['plane { <%d, %d, %d>, %0.2f\n'...
                          '        texture { %s }\n' ...
                          '        %s\n'],...
                          normal(1), normal(2), normal(3), distance, texture, clipped_by);
                          
            o.write_transforms(scale, rotate, translate);
        end
        
        % Surface
        function surface(o, varargin)
            % Creates textured mesh from surface, retuned by Matlab's 'surf'
            % function
            p = inputParser;
            addParameter(p,'surface',      0,                @o.check_surface);
            addParameter(p,'texture',      "tex_default",    @o.check_string);
            addParameter(p,'texture_odd',  "",               @o.check_string);
            addParameter(p,'texture_even', "",               @o.check_string);
            addParameter(p,'finish',       "finish_default", @o.check_string);
            addParameter(p,'smooth',       true,             @islogical);
            addParameter(p,'colormap',     'parula',         @o.check_string);
            addParameter(p,'scale',        [1 1 1],          @o.check_vector3);
            addParameter(p,'rotate',       [0 0 0],          @o.check_vector3);
            addParameter(p,'translate',    [0 0 0],          @o.check_vector3);
            parse(p,varargin{:});

            surface      = p.Results.surface;
            texture      = p.Results.texture;
            texture_odd  = p.Results.texture_odd;
            texture_even = p.Results.texture_even;
            finish       = p.Results.finish;
            smooth       = p.Results.smooth;
            cmap_name    = p.Results.colormap;
            scale        = p.Results.scale;
            rotate       = p.Results.rotate;
            translate    = p.Results.translate;

            has_tex = ~ismember('texture', p.UsingDefaults);
            has_tex_odd  = ~strcmp(texture_odd,  "");
            has_tex_even = ~strcmp(texture_even, "");

            use_colormap = ~has_tex_odd && ~has_tex_even && ~has_tex;
            if(use_colormap)
                mode = 1;
            elseif (has_tex)
                mode = 2;
            else
                mode = 3;
            end

            if(~has_tex_odd)
                texture_odd = texture;
            end
            
            if(~has_tex_even)
                texture_even = texture;
            end

            if(use_colormap)
                cdata = surface.CData;
                cmap = colormap(cmap_name);
                cmin = min(cdata(:));
                cmax = max(cdata(:));
                m = length(cmap);
                index = fix((cdata - cmin) / (cmax - cmin) * m) + 1;
                RGB = ind2rgb(index,cmap);
            end

            function tex = get_cmap_tex(i,j,n)
                 if(n==1)
                    mi=i+1;
                    mj=j;
                 else
                    mi=i;
                    mj=j+1;
                 end
                 tex = sprintf('<%0.5f, %0.5f, %0.5f>, <%0.5f, %0.5f, %0.5f>, <%0.5f, %0.5f, %0.5f>',...
                                RGB(i,  j,  1), RGB(i,  j,  2), RGB(i,  j,  3),...
                                RGB(mi, mj, 1), RGB(mi, mj, 2), RGB(mi, mj, 3),...
                                RGB(i+1,j+1,1), RGB(i+1,j+1,2), RGB(i+1,j+1,3));
            end

            % Write data
            s = size(surface.XData) - 1;
            size_x = s(1);
            size_y = s(2);
            tnum = size_x * size_y * 2;
            if(mode == 1)
                len = 9;
            else
                len = 6;
            end    
            fprintf(o.fh, '#declare V = array[%d][%d] {\n', tnum, len);
            for i=1:size_x
                for j=1:size_y
                    if(mode == 1)
                        tex1 = get_cmap_tex(i,j,1);
                        tex2 = get_cmap_tex(i,j,2);
                    else
                        tex1 = "";
                        tex2 = "";
                    end
                    if (smooth)
                        o.write_smooth_triangle(surface, i,j, i+1,j, i+1,j+1, tex1);
                        o.write_smooth_triangle(surface, i,j, i,j+1, i+1,j+1, tex2);
                    else
                        o.write_triangle(surface, i,j, i+1,j, i+1,j+1, tex1);
                        o.write_triangle(surface, i,j, i,j+1, i+1,j+1, tex2);
                    end
                end
            end
            
            % Write macro call
            fprintf(o.fh, '}\nmake_mesh (%d, V, %d, %s, %s, %s, %s, <%0.5f, %0.5f, %0.5f>, <%0.5f, %0.5f, %0.5f>, <%0.5f, %0.5f, %0.5f>)\n', ...
                          mode,....
                          tnum, ...
                          finish,...
                          texture, texture_odd, texture_even, ...
                          scale(1),     scale(2),     scale(3), ...
                          rotate(1),    rotate(2),    rotate(3), ...
                          translate(1), translate(2), translate(3));
        end
        
        % Wire box
        function wire_box(o, varargin)
            % sphere method help
            p = inputParser;
            addParameter(p,'llf_corner', [0 0 0],      @o.check_vector3);
            addParameter(p,'urb_corner', [0 0 0],      @o.check_vector3);
            addParameter(p,'radius',     1.0,          @o.check_positive_float);
            addParameter(p,'merge',      false,        @islogical);
            addParameter(p,'texture',   "tex_default", @o.check_string);
            addParameter(p,'scale',      [1 1 1],      @o.check_vector3);
            addParameter(p,'rotate',     [0 0 0],      @o.check_vector3);
            addParameter(p,'translate',  [0 0 0],      @o.check_vector3);
            parse(p,varargin{:});

            llf_corner = p.Results.llf_corner;
            urb_corner = p.Results.urb_corner;
            radius     = p.Results.radius;
            merge      = p.Results.merge;
            if(merge)
                merge = 1;
            else 
                merge = 0;
            end    
            texture    = p.Results.texture;
            scale      = p.Results.scale;
            rotate     = p.Results.rotate;
            translate  = p.Results.translate;

            % Write
            fprintf(o.fh, ['object{ Wire_Box (<%0.2f, %0.2f, %0.2f>\n'...
                           '          <%0.2f, %0.2f, %0.2f>, %0.2f, %0.2f)\n'...
                           '          texture { %s }\n'],...
                           llf_corner(1), llf_corner(2), llf_corner(3), ...
                           urb_corner(1), urb_corner(2), urb_corner(3), ...
                           radius,...
                           merge,...
                           texture);
            o.write_transforms(scale, rotate, translate);
        end

        % Plot
        function plot(o, varargin)
            % plot method help
            p = inputParser;
            addParameter(p,'name',    'f',             @o.check_string);            
            addParameter(p,'funcion', 'X',             @o.check_string);
            addParameter(p,'min_x',    -1,             @o.check_float);
            addParameter(p,'max_x',     1,             @o.check_float);
            addParameter(p,'width',     0.05,          @o.check_positive_float);
            addParameter(p,'color',     [0.1 0.4 0.0], @o.check_vector3);
            addParameter(p,'scale',     [1 1 1],       @o.check_vector3);
            addParameter(p,'rotate',    [0 0 0],       @o.check_vector3);
            addParameter(p,'translate', [0 0 0],       @o.check_vector3);
            parse(p,varargin{:});

            name      = p.Results.name;
            func      = p.Results.funcion;
            min_x     = p.Results.min_x;
            max_x     = p.Results.max_x;
            width     = p.Results.width;
            color     = p.Results.color;
            scale     = p.Results.scale;
            rotate    = p.Results.rotate;
            translate = p.Results.translate;
            
            % Write
            fprintf(o.fh,['#declare %s = function(X) { %s }\n'...
                          'union {plot_function(%0.2f, %0.2f, %s, %0.2f, <%0.1f, %0.1f, %0.1f0>)\n'],...
                          name, func,...
                          min_x, max_x, name, width, color(1), color(2), color(3));
            o.write_transforms(scale, rotate, translate);
        end

        % Set cone plot visualization parameters
        function coneplot_material(o, varargin)
            % coneplot_material method help
            p = inputParser;
            addParameter(p,'alpha', 0.8, @o.check_positive_float);
            addParameter(p,'interior', 'ior 0.0',  @o.check_string); % I_Glass
            addParameter(p,'finish',   'crand 0.02', @o.check_string);
            parse(p,varargin{:});

            o.declare("coneplot_alpha",    sprintf("%0.1f;", p.Results.alpha));
            o.declare("coneplot_interior", sprintf("interior {%s};", p.Results.interior));
            o.declare("coneplot_finish",   sprintf("finish   {%s};", p.Results.finish));
        end

        % Surface
        function surface2(o, varargin)
            % surface2 method help
            p = inputParser;
            addParameter(p,'data', 0);
            parse(p,varargin{:});
            data = p.Results.data;
            p = surf2patch(data, 'triangles');
            patch(o, 'data', p);
        end
        
        % Coneplot
        function coneplot(o, varargin)
            % coneplot method help
            p = inputParser;
            addParameter(p,'data', 0);
            parse(p,varargin{:});
            data = p.Results.data;
            
            % Call patch
            fvc.vertices = get(data, 'vertices');
            fvc.faces = get(data, 'faces');
            fvc.facevertexcdata = get(data, 'facevertexcdata');

            patch(o, 'data', fvc);
        end
        
        % Streamtube
        function streamtube(o, varargin)
            % streamtube method help
            p = inputParser;
            addParameter(p,'data', 0);
            parse(p,varargin{:});
            data = p.Results.data;

            tubes = size(data);
            for i=1:tubes
                d = surf2patch(data(i), 'triangles');
                patch(o, 'data', d);
            end
        end

        % Streamline
        function streamline(o, varargin)
            % streamline method help
            p = inputParser;
            addParameter(p,'data', 0);
            parse(p,varargin{:});
            data = p.Results.data;

            lines = size(data);
            for i=1:lines
                xdata = get(data(i), 'XData');
                ydata = get(data(i), 'YData');
                zdata = get(data(i), 'ZData');
                color = get(data(i), 'Color');
                width = get(data(i), 'LineWidth') / 3;
                
                [~,n] = size(xdata);
                fprintf(o.fh, 'sphere_sweep { linear_spline %d,\n', n);
                for j=1:n
                    fprintf(o.fh, '<%0.2f, %0.2f, %0.2f>, %0.2f\n', xdata(j), ydata(j), zdata(j), width);
                end
                fprintf(o.fh, ['tolerance 0.1\n\nmaterial{ texture { Dark_Green_Glass }' ...
                                  'interior{ I_Glass }}\n}']);
            end
        end
        
        % Patch
        function patch(o, varargin)
            % patch method help
            p = inputParser;
            addParameter(p,'data', 0);
            parse(p,varargin{:});
            data = p.Results.data;

            verts = data.vertices;
            verts(isnan(verts))=0;

            faces = data.faces;
            faces(isnan(faces))=0;

            colors = data.facevertexcdata;

            % Start mesh
            fprintf(o.fh, 'mesh2 {\n');

            % Write vertices
            [vnum,~] = size(verts);
            fprintf(o.fh, 'vertex_vectors { %d,\n', vnum);
            for i=1:vnum
                fprintf(o.fh, '<%0.2f, %0.2f, %0.2f>,\n', verts(i,1), verts(i,2), verts(i,3));
            end
            
            % Write faces
            [fnum,~] = size(faces);
            fprintf(o.fh, '}\nface_indices { %d,\n', fnum);
            for i=1:fnum
                fprintf(o.fh, '<%d, %d, %d>,\n', faces(i,1)-1, faces(i,2)-1, faces(i,3)-1);
            end
            % fprintf(o.fh, '}\npigment {rgb 1}\n}');
            % TODO: Glass test
                        fprintf(o.fh, ['}\nmaterial{ texture { Dark_Green_Glass }' ...
                                          'interior{ I_Glass }}\n}']);
        end

        % Volume via df3
        function volume(o, varargin)
            % volume method help
            p = inputParser;
            addParameter(p,'data',         NaN,           @o.check_volume_size);
            addParameter(p,'intervals',    24,            @o.check_positive_int);
            addParameter(p,'ratio',        0.5,           @o.check_float);
            addParameter(p,'samples',      [3 3],         @o.check_vector2);
            addParameter(p,'method',       3,             @o.check_positive_int);
            addParameter(p,'emission',     [0.1 0.1 0.1], @o.check_vector3);
            addParameter(p,'absorption',   [0.1 0.1 0.1], @o.check_vector3);
            addParameter(p,'scattering',   '1, <0,0,0>',  @o.check_string);
            addParameter(p,'confidence',   0.999,         @o.check_float);
            addParameter(p,'variance',     0.001,         @o.density_file);
            addParameter(p,'density_file', 'volume',      @o.check_string);
            addParameter(p,'interpolate',  1,             @o.check_positive_int);
            addParameter(p,'color_map',    [1 1 1 1]      ); % TODO: Check dimensions
            addParameter(p,'scale',        [1 1 1],       @o.check_vector3);
            addParameter(p,'rotate',       [0 0 0],       @o.check_vector3);
            addParameter(p,'translate',    [0 0 0],       @o.check_vector3);
            parse(p,varargin{:});

            data         = p.Results.data;
            intervals    = p.Results.intervals;
            ratio        = p.Results.ratio;
            samples      = p.Results.samples;
            method       = p.Results.method;
            emission     = p.Results.emission;
            absorption   = p.Results.absorption;
            scattering   = p.Results.scattering;
            confidence   = p.Results.confidence;
            variance     = p.Results.variance;
            density_file = p.Results.density_file;
            interpolate  = p.Results.interpolate;
            color_map    = p.Results.color_map;
            scale        = p.Results.scale;
            rotate       = p.Results.rotate;
            translate    = p.Results.translate;

            % Write density file if we have data
            if(~isnan(data))
                [sx,sy,sz] = size(data);
                fhd = fopen(o.out_dir + "/" + density_file + ".df3", 'w');
                fwrite(fhd, sx,   'uint16', 'ieee-be');
                fwrite(fhd, sy,   'uint16', 'ieee-be');
                fwrite(fhd, sz,   'uint16', 'ieee-be');
                fwrite(fhd, data, 'uint8',  'ieee-be');
                fclose(fhd);
            end
            
            % Write
            fprintf(o.fh,['#declare vol_interior = interior {\n'...
                          '    media {\n'...
                          '        intervals %d\n'...
                          '        ratio %0.1f\n'...
                          '        samples  %d,%d\n'...
	                      '        method %d\n'...
                          '        emission <%0.1f, %0.1f, %0.1f0>\n'...
                          '        absorption <%0.2f, %0.2f, %0.2f0>\n'...
                          '        scattering { %s }\n'...
                          '        confidence %0.3f\n'...
                          '        variance %0.3f\n'...
                          '            density {\n'...
    	                  '                density_file df3 "%s.df3"\n'...
                          '                interpolate %d\n' ...
                          '                color_map {\n'],...
                          intervals, ratio, samples(1), samples(2), method,...
                          emission(1),   emission(2),   emission(3),...
                          absorption(1), absorption(2), absorption(3),...
                          scattering, confidence, variance, density_file, interpolate);
            
            % Write colormap
            [cms,~] = size(color_map);
            for c = 1:cms
                fprintf(o.fh,'                    [%0.4f rgb <%0.2f,%0.2f,%0.2f>]\n', color_map(c,1), color_map(c,2), color_map(c,3), color_map(c,4));
            end
            
            % Write container box
            fprintf(o.fh,[                                       '}}}}\n\n'...
                          'box {<0, 0, 0>, <1, 1, 1>\n'...
                               'pigment { rgbf 1 }\n'...
                               'interior { vol_interior }\n'...
                               'hollow\n']);
            o.write_transforms(scale, rotate, translate);
        end

        % CSG:Union
        function union_begin(o)
            % Openes union section CSG, should be closed by corresponding union_end()
            fprintf(o.fh,'union {\n');
        end
        function union_end(o, varargin)
            % Closes union CSG section, openened by union_begin()
            o.csg_end(varargin{:});
        end 

        % CSG:Difference
        function difference_begin(o)
            % Openes difference CSG section, should be closed by corresponding difference_end()
            fprintf(o.fh,'difference {\n');
        end
        function difference_end(o, varargin)
            % Closes difference CSG section, openened by difference_begin()
            o.csg_end(varargin{:});
        end 

        % CSG:Intersection
        function intersection_begin(o)
            % Openes intersection CSG section, should be closed by corresponding intersection_end()
            fprintf(o.fh,'intersection {\n');
        end
        function intersection_end(o, varargin)
            % Closes intersection CSG section, openened by intersection_begin()
            o.csg_end(varargin{:});
        end

        % CSG:Merge
        function merge_begin(o)
            % Openes merge CSG section, should be closed by corresponding intersection_end()
            fprintf(o.fh,'merge {\n');
        end
        function merge_end(o, varargin)
            % Closes merge CSG section, openened by intersection_begin()
            o.csg_end(varargin{:});
        end

        % Render
        function img = render(o)
            % Rendering scene by calling a POV as system process, returns rendered image
            if isunix
                setenv('LD_LIBRARY_PATH', '/usr/local/lib/'); % TODO: Set globally (?)
                system(sprintf('"%s" %s/%s', o.pov_path, o.out_dir, o.scene_file));
            elseif ispc
                command = sprintf('"%s" /RENDER "%s/%s" /EXIT', o.pov_path, o.out_dir, o.scene_file);
                system(command);
            else
                disp('Platform not supported')
            end

            img = o.image_file;
        end
    end % End of public methods

    methods (Access = private)
            %
            % Helper functions
            %
            % Closing tag for all CSG functions
            function csg_end(o, varargin)
                % Common method for closing CSG section of scene
                p = inputParser;
                addParameter(p,'scale',     [1 1 1], @o.check_vector3);
                addParameter(p,'rotate',    [0 0 0], @o.check_vector3);
                addParameter(p,'translate', [0 0 0], @o.check_vector3);
                parse(p, varargin{:});
    
                o.write_transforms(p.Results.scale, p.Results.rotate, p.Results.translate);
            end
        % Write triangle
        % TODO: Fix it according to make_mesh
        function  write_triangle(o, s, x1, y1, x2, y2, x3, y3, tex)
                    fprintf(o.fh, '    triangle {<%0.2f, %0.2f, %0.2f>, <%0.2f, %0.2f, %0.2f>, <%0.2f, %0.2f, %0.2f>\n%s}\n', ...
                                  s.XData(x1,y1), s.YData(x1,y1), s.ZData(x1,y1),...
                                  s.XData(x2,y2), s.YData(x2,y2), s.ZData(x2,y2),...
                                  s.XData(x3,y3), s.YData(x3,y3), s.ZData(x3,y3), tex);
        end
        
        % Write smooth triangle
        function  write_smooth_triangle(o, s, x1, y1, x2, y2, x3, y3, tex)
                    n = s.VertexNormals;
                    fprintf(o.fh, ['{<%+0.8f, %+0.8f, %+0.8f>, <%+0.8f, %+0.8f, %+0.8f>, '...
                                    '<%+0.8f, %+0.8f, %+0.8f>, <%+0.8f, %+0.8f, %+0.8f>, '...
                                    '<%+0.8f, %+0.8f, %+0.8f>, <%+0.8f, %+0.8f, %+0.8f> %s}\n'], ...
                                    s.XData(x1,y1), s.YData(x1,y1), s.ZData(x1,y1), n(x1,y1,1), n(x1,y1,2), n(x1,y1,3),...
                                    s.XData(x2,y2), s.YData(x2,y2), s.ZData(x2,y2), n(x2,y2,1), n(x2,y2,2), n(x2,y2,3),...
                                    s.XData(x3,y3), s.YData(x3,y3), s.ZData(x3,y3), n(x3,y3,1), n(x3,y3,2), n(x3,y3,3), tex);
        end

        % Write transforms
        function  write_transforms(o, scale, rotate, translate)
            fprintf(o.fh, 'scale<%0.2f, %0.2f, %0.2f> rotate <%0.2f, %0.2f, %0.2f> translate <%0.2f, %0.2f, %0.2f>}\n\n',...
                           scale(1), scale(2), scale(3), rotate(1), rotate(2), rotate(3), translate(1), translate(2), translate(3));
        end
        
        %
        % Validation functions
        % ----------------------------------------------------------------------
        % Vector of size '4'
        function r = check_vector4(~, x)
            r = false;
            if (~isvector(x) || isscalar(x) || ~isfloat(x) || length(x) ~= 4)
                error("Input is not a float vector of size '4'");
            end
            r = true;
        end

        % Vector of size '3'
        function r = check_vector3(~, x)
            r = false;
            if (~isvector(x) || isscalar(x) || ~isfloat(x) || length(x) ~= 3)
                error("Input is not a float vector of size '3'");
            end
            r = true;
        end

        % Vector of size '2'
        function r = check_vector2(~, x)
            r = false;
            if (~isvector(x) || isscalar(x) || ~isfloat(x) || length(x) ~= 2)
                error("Input is not a float vector of size '2'");
            end
            r = true;
        end

        % Float
        function r = check_float(~, x)
            r = false;
            if ~isscalar(x)
                error('Input is not scalar');
            elseif ~isfloat(x)
                error('Input is not float');
            end
            r = true;
        end

        % Positive float
        function r = check_positive_float(~, x)
            r = false;
            if ~isscalar(x)
                error('Input is not scalar');
            elseif ~isfloat(x)
                error('Input is not float');
            elseif (x < 0)
                error('Input is negative');
            end
            r = true;
        end

        % Positive float in range 0..1
        function r = check_positive_float_0_1(~, x)
            r = false;
            if ~isscalar(x)
                error('Input is not scalar');
            elseif ~isfloat(x)
                error('Input is not a float');
            elseif (x < 0)
                error('Input is negative');
            elseif ((x < 0) || (x > 1))
                error("Input is not in range '[0 1]'");
            end
            r = true;
        end

        % Positive int
        function r = check_positive_int(~, x)
            r = false;
            if ~isscalar(x)
                error('Input is not scalar');
            elseif floor(x) ~= ceil(x)
                error('Input is not an integer');
            elseif (x < 0)
                error('Input is negative');
            end
            r = true;
        end

        % String
        function r = check_string(~, x)
            r = false;
            if (~isstring(x) && ~ischar(x))
                error('Input is not a string');
            end
            r = true;
        end

        % Matrix '3 x 3'
        function r = check_matrix_3x3(~, x)
            r = false;
            if (~isequal(size(x), [3 3]))
                error("Input is not a matrix of size '3 x 3'");
            end
            r = true;
        end

        % Matrix 3d
        function r = check_volume_size(~, x)
            r = false;
            [sx,sy,sz] = size(x);
            if ((sx < 2) && (sy < 2)  ||...
               ((sy < 2) && (sz < 2)) ||...
               ((sx < 2) && (sz < 2)))
                error("Input has no enougth size or dimentions");
            end
            r = true;
        end

        % Points list [x1 y1; .. ;xn yn])
        function r = check_points_list(~, x)
            r = false;
            s = size(x);
            if (s(1) < 2 || s(2) ~= 2)
                error("Input is not a points list like '[x1 y1; .. ;xn yn]'");
            end
            r = true;
        end
        
        % Surface
        function r = check_surface(~, x)
            r = false;
            if (~isa(x, 'matlab.graphics.chart.primitive.Surface'))
                error('Input is not a surface');
            end
            r = true;
        end
    end  % End of private methods

    % Hiding derived methods to keep help clean
    methods (Hidden)
        function addlistener(varargin)
          addlistener@addlistener(varargin{:})
        end

        function le(varargin)
          le@le(varargin{:})
        end

        function lt(varargin)
            lt@lt(varargin{:})
        end

        function gt(varargin)
          gt@gt(varargin{:})
        end

        function ge(varargin)
          ge@ge(varargin{:})
        end

        function ne(varargin)
          ne@ne(varargin{:})
        end

        function eq(varargin)
          eq@eq(varargin{:})
        end

        function findobj(varargin)
          findobj@findobj(varargin{:})
        end

        function findprop(varargin)
          findprop@findprop(varargin{:})
        end

        function notify (varargin)
          notify@notify(varargin{:})
        end

%         function ObjectBeingDestroyed (varargin)
%           ObjectBeingDestroyed@ObjectBeingDestroyed(varargin{:})
%         end
       
    end % End of hidden methods
end
